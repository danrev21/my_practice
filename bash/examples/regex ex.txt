Внимание!
В sed довольно проблемно работать с символом перевода строки!  Самое удобное решение - это:
echo "text" | perl -pe 's/\n/_/'

В качестве разделителей можно использовать любые символы (напрмиер: #, @). Match части (которые внутри круглых скобок) доступны как \1, \2, \n.

.*[]^${}\+?|()    # специальные символы
.	 любому символу;
[ ]	 диапазону символов;
[^ ]	 всем символам, кроме указанных в фигурных скобках;
*	 любому количеству символов, предшествующих звездочке, в том числе нулю;
+	 одному или нескольким из стоящих перед ним выражений;
?	 нулю или одному из стоящих перед ним выражений;
{n}	 'n' повторениям предшествующих выражений;
{n,}	 не менее 'n' повторениям предшествующих выражений;
{n m}	 не менее 'n' и не более 'm' повторениям предшествующих выражений;
{,m}	 не более или равному 'm' повторениям предшествующих выражений;
\        является escape-символом (символом экранирования), используемым, когда нужно включить один из метасимволов.
\d	цифры (тоже, что [0-9])
\D	не цифры.
\s	пробельные символы, табы, новые строки (такой же как [\t\n\r\f])
\S	все, кроме \s.
\w	латиница, цифры, подчёркивание '_'.
\W	все, кроме \w.
. 	любой символ, если с флагом регулярного выражения s, в противном случае любой символ, кроме перевода строки \n.
\h	горизонтальный разделитель. Табуляция, пробел и все символы
	в Unicode категории «разделители» (space separator Unicode category)
\H	не горизонтальный разделитель
\v	вертикальные разделители. новая строка и все символы
	«разделители строк» в Unicode
\V	не вертикальный разделитель
^	совпадение нулевой длины в начале строки
$	совпадение нулевой длины в конце строки
\A	совпадение нулевой длины в начале строки
\z	совпадение нулевой длины в конце строки
\Z	похож на \z но совпадает перед разделителем строки, а не сразу после него, как \z
\b	разделитель слов
\B	разделитель с не-словом

Опции утилиты sed:
-p   вывести на экран
-d   удалить
-i   выполнять изменения непосредственно в файле
-n   не выводить результат замены/поиска на экран (--quiet, --silent)

-e   указывает на передачу инструкции (команда замены/удаления или выражение для поиска/фильтрации). Нужен, если Вы передаете более 1 инструкции

-E   расширенный regex, ближе к JavaScript, Go. Активны спец символы: [0-9]+
-r   расширенный regex синтаксис. Спец символы активны по умолчанию (--regexp-extended)
-P   perl-совместимый regex синтаксис

-s   consider files as separate rather than as a single continuous long stream (--separate)

Флаги строки-команды (указывать в конце маски):

g    глобальный поиск/замена, а не только первое совпадение
i,-l регистро-независимый поиск
p,   печать найденных подстрок
d    удалить строки

s/"/\\"/;   # Escape " with \
s/.*/"&",/; # Оберните всю строку в двойные кавычки и вставьте запятую
s/^/[/;    # Insert [ at first line
s/,$/]/    # Insert ] at last line and remove конечная запятая

sed [-opt] 's/regex/replace/flag' input-file
head -c -1			# удалить последний \n в файле
cut -c 1 text.txt               # вывести первый символ строки
sed 's/regex/replace/flag'      # замена найденных подстрок
sed '1,5s/regex/replace/gi'     # замена только в указанном диапазоне строк
sed -r 's/regex/replace/g'      # расширенный синтаксис regex (со спец символами)
sed 's/regex//g'                # удалить найденные подстроки
sed '/regex/d'                  # удалить строки подходящие по маске
sed -n 2p                       # вывести 2ю строку
sed -n '/composer/p'            # вывести только строки подходящие по маске
sed -e "s/^.//;s/.$//"          # удалить первый и последний символ строки
				Количеством точек регулировать сколько символов нужно 				убрать (точка — это замена любого символа, одна точка — 				один символ).
sed 's/1-9/&/p'                 # & при замене означает сам ОБРАЗЕЦ
sed "s/[0-9]*/& &/"             # Еще символ амперсанда можно использовать для удвоения ОБРАЗЦА
awk '{ $1=$3=""; sub(/^ */,"",$0) }1' file - # удалить лишние пробелы в начале строки
sed 's/ *$//'			# Убрать пробелы в конце строки
sed 's/^ *//g'                  # Удалить начальные пробелы (аналог ltrim)
sed 's/^[ \t]*//;s/[ \t]*$//'   # Удалить пробелы в начале и конце
sed 's/^[[:blank:]]*//;s/[[:blank:]]*$//' # same
awk '{$1=$1;print}'             # Удалить пробелы в начале и конце с awk
  или короче:
awk '{$1=$1};1'
sed "s/..$//" 			# удалить 2 последних символа
sed -z 's/^\n//'		# удалить первый \n
sed -z '$ s/...\n$//'		# удалить три \n в конце строки (три точки)
sed ":a;N;$!ba;s/\n//g"		# удалить все \n кроме последнего
sed -r 's/ ([0-9]+)$/\t\1/'	# пробел перед цифрами заменить на знак табуляции
echo '[123]' | sed 's/[][]//g'  # удалить скобки, содержимое оставить
123
sed 's/[][?!]//g'               # удалить скобки [], содержимое оставить
sed 's/.*\[//;s/\].*//;'        # удалить все до и после скобок
sed 's/$/GHJ/g' 		# добавить GHJ в конце каждой строки
sed -e '$ s/.$/&\,/'            # добавить запятую в конце последней строки
sed -E '2s/(.{4})/&\*/'		# вводим звездочку после 4-го символа строки 2
sed -r 's/(^[0-9]+)\s/\1;/g'    # добавляем ; после числа в начале строки
echo "aaaaaaa" | sed 's/a/A/3'  # Меняется только третья буква «a».
aaAaaaa
echo "aaaaaaa" | sed 's/a/A/3g' # меняеются буквы с третьей и остальные
aaAAAAA
/Q{7}/         # ищет в строке 7 букв Q подряд. Можно задать диапазон, например
/Q{3,9}/       # ищет от 3х до девяти букв Q
sed s/.*([-+]?[0-9]+).*/\1/     # выделит из строки последнее целое десятичное число со знаком.
/(.).*\1/      # найти 2 одинаковых символа
/^(.*)\n\1$/   # найти только одинаковые строки, разделённые символом `\n'
[^ ]*          # соответствует всем символам, кроме пробела
s/(.*)X/\1Y/   # приведёт к замене именно последней X на Y (если Х точно совпадает)
sed -re 's/,([^.]*),/;\1;/g'        # замена запятых, кроме запятых в скобках
sed 's/\([a-z]*\).*/\1/'            # Здесь \([a-z]*\) означает, что программа должна запомнить все буквенные символы в любом количестве; .* означает любое количество символов после первой запомненной части; а \1 означает , что мы хотим видеть только первую запомненную часть. Так и есть: в выводе программы мы видим только буквы и никаких цифр - abcd
----
echo глупый пингвин | sed 's/\([а-я]*\) \([а-я]*\)/\2 \1/'
 пингвин глупый
Здесь \2 означает второй суб-ОБРАЗЕЦ, а \1 -первый. Обратите внимание на интервал между первым выражением \([а-я]*\) и вторым выражением \([а-я]*\). Он необходим, чтобы были найдены два слова.
----
Знак \1 вовсе не обязан быть только в ЗАМЕНЕ, он может присутствовать также и в ОБРАЗЦЕ, например, когда мы хотим удалить дубликаты слов:
 echo пингвин пингвин | sed 's/\([а-я]*\) \1/\1/'
 пингвин
----
sed = firstfile.txt | sed 'N;s/\n/\t/'		# нумерование строк
sed -i 's/\[0-9\] \ [0-9\]//g'			# Удаление всех чисел из текста




Вывести строки 1-5:
sed '1,5p'
head -5

Вывести файлы соответствующие маске:
ls | sed -n '/composer/p'

Строки длиннее 80 символов:
sed -n '/^.{80}/p'
sed -n '/^.{80}/!p' # короче 80 символов

Замена по шаблону
Вывести вхождения (matches) через табуляцию:
sed -r 's/^ +([^ ]+) +(.+)$/\1\t\2/'

Заменить символы (regex):
echo 'aa,bb,xx' | sed "s/xx/cc/g" # aa,bb,cc

Заменить URL в файле (штука в разделителях |, и -i для замены в файле):
sed -i "s|$old_site_url|$new_site_url|g" file.yml

Заменить параметр в конфиге:
sed -ie '/project_file_path *=/ s|=.*$|=/home/pi/apps|' ~/.config/geany/geany.conf

Заменить значение в xml-конфиге:
sed -i -r 's/(name="width" value=")[^"]+"/\148KP"/' /etc/ImageMagick-6/policy.xml


Удаление строк

Удалить из файла строку подходящую шаблону:
sed '/regex/d' /path/file

Удалить первую строку вывода:
sed 1d        # удалить первую строку
sed '5, 10d'  # удалить строки c 5-й по 10-ю

Удалить строки от первой до соответствующей regex:
sed "1,/end string pattern/d"

Заменить подстроку:
echo '--some string' | sed 's/\(Some\)/New \1/i' # --New some string

Примечание
По умолчанию необходимо экранировать все спец. символы в regex'ах, что крайне затрудняет чтение масок. Для того, чтобы экранировать спец.символы только в случае описания в тексте их самих - включите расширенный режим regex выражений с помощью опции -r.

Удалить пустые строки:
sed '/^$/d'

Извлечение подстрок

Вырезать / запомнить последние N=4 символа:
echo "latest" | sed "s/.*\(....$\)/\1/" # test

Вставка содержимого файла после строки
Иногда требуется вставить содержимое одного файла (input_file.txt) после определенной строки другого (firstfile.txt). Для этой цели используется команда:
sed ‘5r input_file.txt’ firstfile.txt (где «5r» — 5 строка, «input_file.txt» — исходный файл и «firstfile.txt» — файл, в который требуется вставить массив текста).








































































