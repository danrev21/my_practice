arr=()	Создание пустого массива
arr=(1 2 3)	Инициализация массива
${arr[2]}----	Получение третьего элемента массива
${arr[@]}	Получение всех элементов массива
${!arr[@]}---	Получение индексов массива
${#arr[@]}	Вычисление размера массива
${#arr[2]}---	Узнать длину третьего элемента массива (сколько символов)
arr[0]=3	Перезапись первого элемента массива
arr+=(4)-----	Присоединение к массиву значения
str=$(ls)	Сохранение вывода команды ls в виде строки
arr=( $(ls) )-	Сохранение вывода команды ls в виде массива имён файлов
${arr[@]:s:n}-	Получение элементов массива начиная с элемента с индексом s до элемента с индексом s+(n-1)

---------------------------------------------------------------
#слово в МАССИВ

SURNAME="asdfg"
declare -a ARRAY 
array_surname=${#SURNAME} 
for ((i=0; i<=$((array_surname-1)); i++)) 
do 
        ARRAY=( "${ARRAY[@]}" "${SURNAME:$i:1}") 
done 

echo ${ARRAY[2]}


allThreads=(1 2 4 8 16 32 64 128)
--------------------------------------
myArray=(1 2 "three" 4 "five")
-----------------------------------------
echo ${allThreads[$i]}
---------------------------------------------
for t in ${allThreads[@]}; do   #Перебор элементов массивов в циклах
  ./pipeline --threads $t
done
----------------------------------------------
for i in ${!allThreads[@]}; do           #Перебор индексов массивов в циклах
  ./pipeline --threads ${allThreads[$i]}
done
----------------------------------------------
myArray+=( "newElement1" "newElement2" )  #присоединять к массивам новые данные
---------------------------------------------------------
#выполняет команду с каждым из значений параметра из массива и сохраняет 
#в другом массиве то, что выводит эта команда
allThreads=(1 2 4 8 16 32 64 128)
allRuntimes=()
for t in ${allThreads[@]}; do
  runtime=$(./pipeline --threads $t)
  allRuntimes+=( $runtime )
done
-------------------------------------
# файл в массив
mapfile -t arr < output_lower_surename.csv
------------------------------
#строку в массив
IFS=', ' read -a array <<< "Paris, France, Europe"; echo "${array[@]}"   
-------------------------------------------
NEW=("${OLD1[@]}" "${OLD2[@]}")
------------------------------------
#Вот как я объединил два массива в Bash:
#Примеры массивов:
AR=(1 2 3) BR=(4 5 6)
CR=($(echo ${AR[*]}) $(echo ${BR[*]}))
--------------------------------------------
combine=( `echo ${array1[@]}` `echo ${array2[@]}` )  #тоже объединение
-----------------------------------------------
a=(0 1); b=(2 3)
i=0
for z in ${a[@]}
do
    for y in ${b[@]}
    do
        c[i++]="$z:$y"
    done
done
declare -p c   # dump the array
Выходы:
declare -a c='([0]="0:2" [1]="0:3" [2]="1:2" [3]="1:3")'
-----------------------------------------------------------------------
len=${#ar[*]}           #вычитание от каждого элемента 800
for (( i=0; i<=$(( $len -1 )); i++ ))
do
    ar[$i]=$((${ar[$i]} - 800))
done
---------------------------------------------------------------
len=${#arr[*]}                        #вычитание от элементов 2..8
for (( c=0, k=2; c<=$(( $len -1 )); c++, k++ ))
do
  arr[$c]=$((${arr[$c]} - k))
done
---------------------------------------------------------------------------------------------------------















awk -F '' 'BEGIN { RS = ""; OFS = "\n"} {for (i=1;i<=NF;i++) $i = $i; print }' <file_name>






