Я также пытался преобразовать несколько строк в массив JSON и остановился, пока не понял, что -s единственный способ обрабатывать более одной строки за раз в выражении jq, даже если бы это означало, что мне придется анализировать переводы строк вручную.

jq -R -s -c 'split("\n")' < just_lines.txt
-R для чтения необработанного ввода
-s для чтения всех входных данных в виде одной строки
-c чтобы не печатать вывод
-----------------------------------------------------------------------------
Вы также можете использовать jq -R ., чтобы отформатировать каждую строку как строку JSON, а затем jq -s (--slurp) для создания массива для строк ввода после анализа их в формате JSON:
printf %s\\n aa bb|jq -R .|jq -s .
-------------------------------------------------------------------
Метод в ответе chbrown добавляет пустой элемент в конец, если ввод заканчивается переводом строки, но вы можете использовать printf %s "$(cat)" для удалить завершающие переводы строки:
 $ printf %s\\n aa bb|jq -R -s 'split("\n")'
[
  "aa",
  "bb",
  ""
]
$ printf %s\\n aa bb|printf %s "$(cat)"|jq -R -s 'split("\n")'
[
  "aa",
  "bb"
]
---------------------------------------------------------------------------------------
echo '{"fruit":{"name":"apple","color":"green","price":1.20}}' | jq '.'
{
  "fruit": {
    "name": "apple",
    "color": "green",
    "price": 1.2
  }
}
----------
We can also apply this filter directly to a JSON file:
jq '.' fruit.json
-------------------------------------------------------------------------


























































































































