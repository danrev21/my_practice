echo "This is a test 2 again" | awk '/test 2/{print $0}'
---------------------------------------
.*[]^${}\+?|()
Если один из них нужен в шаблоне, его нужно будет экранировать с помощью обратной косой черты (обратного слэша) — \.
-------------------------------------------------------
Знак доллара можно обнаружить с помощью такого шаблона:
$ awk '/\$/{print $0}' myfile
-----------------------------------------------------------------------
Кроме того, обратная косая черта — это тоже специальный символ, поэтому, если нужно использовать его в шаблоне, его тоже надо будет экранировать. Выглядит это как два слэша, идущих друг за другом:
$ echo "\ is a special character" | awk '/\\/{print $0}'
---------------------
для прямого слэша тоже экранирование
$ echo "3 / 2" | awk '/\//{print $0}'
------------------------------------------------------------
Символ «крышка» — ^ позволяет описывать последовательности символов, которые находятся в начале текстовых строк.  . Выглядит использование этого символа так:
$ echo "welcome to likegeeks website" | awk '/^likegeeks/{print $0}' ---регулярное выражение на него не отреагирует
$ echo "likegeeks website" | awk '/^likegeeks/{print $0}'
likegeeks website
--------------------------------------------------------------------------------------------------------------------
$, являющийся якорным символом конца строки:
$ echo "This is a test" | awk '/test$/{print $0}'
This is a test
-------------------------------------------
Вот как, пользуясь якорными символами, отфильтровать пустые строки:
$ awk '!/^$/{print $0}' myfile
символ отрицания, восклицательный знак — !
--------------------------------------------------------------------
Точка используется для поиска любого одиночного символа, за исключением символа перевода строки
$ awk '/.st/{print $0}' myfile
test
----------------------------------------------
Для описания класса символов используются квадратные скобки — []
$ awk '/[oi]th/{print $0}' myfile
Тут мы ищем последовательность символов «th», перед которой есть символ «o» или символ «i».
-----------------------------------------------------
Поиск слов, которые могут начинаться со строчной или прописной буквы
$ echo "this is a test" | awk '/[Tt]his is a test/{print $0}'
$ echo "This is a test" | awk '/[Tt]his is a test/{print $0}'
----------------------------------------
можно организовать поиск всего, что в класс не входит c помощью ^
$ awk '/[^oi]th/{print $0}' myfile
---------------------------------------------------------------------
В символьных классах можно описывать диапазоны символов, используя тире:
$ awk '/[e-p]st/{print $0}' myfile
----------------------------------------------------------------------
Регулярное выражение для поиска трёх любых чисел
$ echo "123" | awk '/[0-9][0-9][0-9]/'
---------------------------------------------------------------------
Класс символов, состоящий из нескольких диапазонов
$ awk '/[a-fm-z]st/{print $0}' myfile
-----------------------------------------------------------------------------
Поиск четного числа в 3м столбце
awk 'BEGIN{FS=OFS=":"} $3 ~ /d*[02468]$/ {$NF="/bin/zsh"}{print $0}' passwd_new
---------------------------------------------------------------------
Специальные классы символов
В BRE имеются специальные классы символов, которые можно использовать при написании регулярных выражений:
[[:alpha:]] — соответствует любому алфавитному символу, записанному в верхнем или нижнем регистре.
[[:alnum:]] — соответствует любому алфавитно-цифровому символу, а именно — символам в диапазонах 0-9, A-Z, a-z.
[[:blank:]] — соответствует пробелу и знаку табуляции.
[[:digit:]] — любой цифровой символ от 0 до 9.
[[:upper:]] — алфавитные символы в верхнем регистре — A-Z.
[[:lower:]] — алфавитные символы в нижнем регистре — a-z.
[[:print:]] — соответствует любому печатаемому символу.
[[:punct:]] — соответствует знакам препинания.
[[:space:]] — пробельные символы, в частности — пробел, знак табуляции, символы NL, FF, VT, CR.
--------------------------------------------------------------------------
Специальные классы символов в регулярных выражениях
$ echo "abc" | awk '/[[:alpha:]]/{print $0}'
$ echo "abc" | awk '/[[:digit:]]/{print $0}'
$ echo "abc123" | awk '/[[:digit:]]/{print $0}'
-------------------------------------------------------------------------
Использование символа * в регулярных выражениях когда
символ появляется в строке любое количество раз — включая и ситуацию, когда символ в строке отсутствует
$ echo "test" | awk '/tes*t/{print $0}'    ---no out
$ echo "tessst" | awk '/tes*t/{print $0}'
tessst
обычно используют для работы со словами, в которых постоянно встречаются опечатки, или для слов, допускающих разные варианты корректного написания
---------------------------------------------------------------------------------
Шаблон, реагирующий на любое количество любых символов
$ awk '/this.*test/{print $0}' myfile
неважно сколько и каких символов находится между словами «this» и «test».
--------------------------------------------------------------------------
Если будет найдено любое количество символов «a» или «e», а также если их найти не удастся, строка будет соответствовать заданному шаблону.
$ echo "st" | awk '/s[ae]*t/{print $0}'   -st
$ echo "sat" | awk '/s[ae]*t/{print $0}'  -sat
$ echo "set" | awk '/s[ae]*t/{print $0}'  -set
-----------------------------------------------------------------------
ТОЛЬКО ДЛЯ AWK - ?
Вопросительный знак указывает на то, что предшествующий символ может встретиться в тексте один раз или не встретиться вовсе. Этот символ — один из метасимволов повторений. Вот несколько примеров:
$ echo "tet" | awk '/tes?t/{print $0}'   -tet
$ echo "test" | awk '/tes?t/{print $0}'  -test
$ echo "tesst" | awk '/tes?t/{print $0}' ---
--------------------------------------------------------------------------------
Если символов из класса в строке нет, или один из них встречается один раз, регулярное выражение срабатывает, однако стоит в слове появиться двум символам и система уже не находит в тексте соответствия шаблону.
$ echo "tst" | awk '/t[ae]?st/{print $0}'   -tst
$ echo "test" | awk '/t[ae]?st/{print $0}'  -test
$ echo "tast" | awk '/t[ae]?st/{print $0}'  -tast
$ echo "taest" | awk '/t[ae]?st/{print $0}' ---
$ echo "teest" | awk '/t[ae]?st/{print $0}' ---
----------------------------------------------------------------------------
Символ «плюс» в шаблоне указывает на то, что регулярное выражение обнаружит искомое в том случае, если предшествующий символ встретится в тексте один или более раз. При этом на отсутствие символа такая конструкция реагировать не будет:
$ echo "test" | awk '/te+st/{print $0}'   -test
$ echo "teest" | awk '/te+st/{print $0}'  -teest
$ echo "tst" | awk '/te+st/{print $0}'    ---
---------------------------------------------------------------------------------------------
В данном примере, если символа «e» в слове нет, движок регулярных выражений не найдёт в тексте соответствий шаблону. Символ «плюс» работает и с классами символов — этим он похож на звёздочку и вопросительный знак:
$ echo "tst" | awk '/t[ae]+st/{print $0}'      
$ echo "test" | awk '/t[ae]+st/{print $0}'   -test 
$ echo "teast" | awk '/t[ae]+st/{print $0}'  -teast
$ echo "teeast" | awk '/t[ae]+st/{print $0}' -teeast
------------------------------------------------------------------------------------------------














































